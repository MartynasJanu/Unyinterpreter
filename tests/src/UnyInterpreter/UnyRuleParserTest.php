<?php

namespace UnyInterpreter;

require_once 'src/UnyInterpreter/UnyRuleParser.php';

/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-10-14 at 22:01:17.
 */
class UnyRuleParserTest extends \PHPUnit_Framework_TestCase
{

    /**
     * @var UnyRuleParser
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->object = new UnyRuleParser;
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {

    }

    /**
     * @covers UnyInterpreter\UnyRuleParser::parse
     * @dataProvider getTestRules
     */
    public function testParse($test)
    {
        $this->object->parse($test['rules']);

        $this->assertEquals($test['states'], $this->object->states);
        $this->assertEquals($test['transitions'], $this->object->transitions);
    }

    /** Possible cases:
     * A1 - text conditions
     * A2 - [epsilon] conditions
     * A3 - [whitespace] conditions
     * A4 - [alfanum] conditions
     *
     * B1 - no callback
     * B2 - callback function
     *
     * C1 - transition to other state
     * C2 - transition to self
     *
     * A1B1C1
     * A1B1C2
     * A1B2C1
     * A1B2C2
     * A2B1C1
     * A2B1C2
     * A2B2C1
     * A2B2C2
     * A3B1C1
     * A3B1C2
     * A3B2C1
     * A3B2C2
     * A4B1C1
     * A4B1C2
     * A4B2C1
     * A4B2C2
     *
     */
    public function getTestRules()
    {
        $conditions = [
            'string:literal',
            '[epsilon]',
            '[whitespace]',
            '[alfanum]',
        ];
        $callbacks = [
            '',
            'startState',
        ];
        $self_trans = [
            true,
            false,
        ];

        $tests = [];
        foreach ($conditions as $condition) {
            foreach ($callbacks as $callback) {
                foreach ($self_trans as $self) {
                    $state = 1;
                    $rules = '';
                    $states = [];
                    $transitions = [];

                    $rules .= "STATE{$state}\n";
                    $states[] = "STATE{$state}";
                    ++$state;
                    $rules .= "STATE{$state}\n";
                    $states[] = "STATE{$state}";
                    $transitions['STATE'.($state - 1)][$condition] = [];

                    $rules .= $condition."\n";
                    $transitions['STATE'.($state - 1)][$condition]['target'] = "STATE{$state}";
                    if (!empty($callback)) {
                        $rules .= $callback."\n";
                        $transitions['STATE'.($state - 1)][$condition]['callback'] = $callback;
                    } else {
                        $transitions['STATE'.($state - 1)][$condition]['callback'] = null;
                    }

                    $rules .= "\n";
                    $rules .= "STATE{$state}\n";
                    if (!$self) {
                        --$state;
                    }
                    $rules .= "STATE{$state}\n";
                    $transitions['STATE'.$state][$condition] = [];

                    $rules .= $condition."\n";
                    $transitions['STATE'.$state][$condition]['target'] = "STATE{$state}";
                    if (!empty($callback)) {
                        $rules .= $callback."\n";
                        $transitions['STATE'.$state][$condition]['callback'] = $callback;
                    } else {
                        $transitions['STATE'.$state][$condition]['callback'] = null;
                    }

                    $tests[] = [
                        'rules' => $rules,
                        'states' => $states,
                        'transitions' => $transitions,
                    ];
                }
            }
        }

        return [
            $tests,
        ];
    }
}
